{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> Usage \u2022     FAQ </p>"},{"location":"#normi-nonparametric-normalized-mutual-information-estimator-based-on-k-nn-statistics","title":"NorMI: Nonparametric Normalized Mutual Information Estimator Based on k-NN Statistics","text":"<p>This software provides an extension to the Kraskov-Estimator to allow normalizing the mutual information.</p> <p>The method was published in:  </p> <p>Accurate estimation of the normalized mutual information of multidimensional data D. Nagel, G. Diez, and G. Stock, J. Chem. Phys. 2024 161, 054108 doi: 10.1063/5.0217960</p> <p>If you use this software package, please cite the above mentioned paper.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Intuitive usage via module and via CI</li> <li>Sklearn-style API for fast integration into your Python workflow</li> <li>No magic, only a  single parameter which can be optimized via cross-validation</li> <li>Extensive documentation and detailed discussion in publication</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The package is called <code>normi</code> and is available via PyPI or conda. To install it, simply call: <pre><code>python3 -m pip install --upgrade normi\n</code></pre> or <pre><code>conda install -c conda-forge normi\n</code></pre> or for the latest dev version <pre><code># via ssh key\npython3 -m pip install git+ssh://git@github.com/moldyn/NorMI.git\n\n# or via password-based login\npython3 -m pip install git+https://github.com/moldyn/NorMI.git\n</code></pre></p>"},{"location":"#shell-completion","title":"Shell Completion","text":"<p>Using the <code>bash</code>, <code>zsh</code> or <code>fish</code> shell click provides an easy way to provide shell completion, checkout the docs. In the case of bash you need to add following line to your <code>~/.bashrc</code> <pre><code>eval \"$(_NORMI_COMPLETE=bash_source normi)\"\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p>In general one can call the module directly by its entry point <code>$ normi</code> or by calling the module <code>$ python -m normi</code>. The latter method is preferred to ensure using the desired python environment. For enabling the shell completion, the entry point needs to be used.</p>"},{"location":"#ci-usage-directly-from-the-command-line","title":"CI - Usage Directly from the Command Line","text":"<p>The module brings a rich CI using click. For a complete list of all options please see the docs. <pre><code>python -m normi /\n  --input input_file  / # ascii file of shape (n_samples, n_features)\n  --output output_file  / # creates ascii file of shape (n_features, n_features)\n  --n-dims / # this allows to treat every n_dims columns as a high dimensional feature\n  --verbose\n</code></pre></p>"},{"location":"#module-inside-a-python-script","title":"Module - Inside a Python Script","text":"<pre><code>from normi import NormalizedMI\n\n# Load file\n# X is np.ndarray of shape (n_samples, n_features)\n\nnmi = NormalizedMI()\nnmi_matrix = nmi.fit_transform(X)\n...\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<ul> <li>Logo generated with DALL\u00b7E 3 by @gegabo</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is inspired by Keep a Changelog, and Element and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#bugfix","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix error introduced in #8 by not supporting lists as arguments</li> </ul>"},{"location":"changelog/#021-2024-10-08","title":"0.2.1 - 2024-10-08","text":""},{"location":"changelog/#added-features-and-improvements","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Allowing to use features of different dimensions by @marko-tuononen</li> </ul>"},{"location":"changelog/#other-changes","title":"Other changes:","text":"<ul> <li>Upgrade gh actions to latest version</li> </ul>"},{"location":"changelog/#020-2024-03-11","title":"0.2.0 - 2024-03-11","text":""},{"location":"changelog/#api-changes-warning","title":"API changes warning \u26a0\ufe0f:","text":"<ul> <li>Changed default for invariant measure to <code>volume</code></li> <li>Changed default for normalization method to <code>geometric</code></li> </ul>"},{"location":"changelog/#added-features-and-improvements_1","title":"Added Features and Improvements \ud83d\ude4c:","text":"<ul> <li>Added an icon, thx to @gegabo</li> </ul>"},{"location":"changelog/#bugfix_1","title":"Bugfix \ud83d\udc1b:","text":"<ul> <li>Fix beartype warning for small number of samples</li> </ul>"},{"location":"changelog/#011-2023-11-07","title":"0.1.1 - 2023-11-07","text":""},{"location":"changelog/#added-features-and-improvements_2","title":"Added Features and Improvements \ud83d\ude4c","text":"<ul> <li>Add python 3.12 support</li> </ul>"},{"location":"changelog/#other-changes_1","title":"Other changes:","text":"<ul> <li>Slightly improved Readme and docs</li> </ul>"},{"location":"changelog/#010-2023-09-13","title":"0.1.0 - 2023-09-13","text":"<ul> <li>Initial release \ud83c\udf89</li> </ul>"},{"location":"contributing/","title":"Welcome to the <code>normi</code> Contributing Guide","text":"<p>This guide will give you an overview of the contribution workflow from opening an issue and creating a PR. To get an overview of the project, read the module overview.</p>"},{"location":"contributing/#issues","title":"Issues","text":""},{"location":"contributing/#create-a-new-issue","title":"Create a new issue","text":"<p>If you spot a bug, want to request a new functionality, or have a question on how to use the module, please search if an issue already exists. If a related issue does not exist, feel free to open a new issue.</p>"},{"location":"contributing/#solve-an-issue","title":"Solve an issue","text":"<p>If you want to contribute and do not how, feel free to scan through the existing issues.</p>"},{"location":"contributing/#create-a-new-pull-request","title":"Create a new pull request","text":""},{"location":"contributing/#create-a-fork","title":"Create a fork","text":"<p>If you want to request a change, you first have to fork the repository.</p>"},{"location":"contributing/#setup-a-development-environment","title":"Setup a development environment","text":"bash + condabash + venvzsh + condazsh + venv <pre><code>conda create -n normi -c conda-forge python=3.12\nconda activate normi\npython -m pip install -e .[all]\n</code></pre> <pre><code>python -m venv ./normi\nsource ./normi/bin/activate\npython -m pip install -e .[all]\n</code></pre> <pre><code>conda create -n normi -c conda-forge python=3.12\nconda activate normi\npython -m pip install -e .\\[all]\n</code></pre> <pre><code>python -m venv ./normi\nsource ./normi/bin/activate\npython -m pip install -e .\\[all]\n</code></pre>"},{"location":"contributing/#make-changes-and-run-tests","title":"Make changes and run tests","text":"<p>Apply your changes and check if you followed the coding style (PEP8) by running <pre><code>python -m flake8 --config flake8-CI.cfg\n</code></pre> All errors pointing to <code>./build/</code> can be neglected.</p> <p>If you add a new function/method/class please ensure that you add a test function, as well. Running the test simply by <pre><code>pytest\n</code></pre> Ensure that the coverage does not decrease.</p>"},{"location":"contributing/#open-a-pull-request","title":"Open a pull request","text":"<p>Now you are ready to open a pull request and please do not forget to add a description.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#should-i-upgrade-the-package","title":"Should I upgrade the package?","text":"<p>You can check out the CHANGELOG.md to see what changed.</p>"},{"location":"faq/#how-can-i-interpret-the-results","title":"How can I interpret the results?","text":"<p>Check out our publication for two detailed examples.</p>"},{"location":"faq/#is-it-possible-to-install-the-cli-only","title":"Is it possible to install the CLI only?","text":"<p>Partially, yes. If you do not want to screw up your current Python environment there are multiples possibilities. Either create a virtual environment on your own via <code>conda</code> or <code>venv</code>, or you can simply use pipx.</p>"},{"location":"faq/#feature-x-is-missing","title":"Feature X is missing","text":"<p>If you believe that a crucial functionality/method is missing, feel free to open an issue and describe the missing functionality and why it should be added. Alternatively, you can implement it yourself and create a PR to add it to this package, see contributing guide.</p>"},{"location":"faq/#i-found-a-bug-what-to-do-next","title":"I found a bug. What to do next?","text":"<p>If you find a bug in this package, it is very kind of you to open an issue/bug report. This allows us to identify and fix the problem, thus improving the overall quality of the software for all users. By providing a clear and concise description of the problem, including steps to reproduce it, and relevant information such as device, operating system, and software version, you will help us resolve the problem quickly and effectively. Submitting a bug report is a valuable contribution to the software and its community, and is greatly appreciated by the development team.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2023 Biomolecular Dynamics</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"maintenance/","title":"Welcome to the <code>normi</code> Maintenance Guideline","text":"<p>This guide will give you an overview of how to publish a new version of normi. In the following we will refer to the new version as <code>v0.*.*</code>. This needs to be substituted to the current version, e.g. <code>v0.1.3</code>.</p>"},{"location":"maintenance/#prepare-new-release","title":"Prepare New Release","text":"<p>Please ensure that,</p> <ol> <li>the version number in <code>setup.py</code> and <code>src/normi/__init__.py</code> are bumped,</li> <li>a new tag is created via <code>git tag v0.*.*</code> and pushed <code>git push --tags</code>, and </li> <li>the changelog includes the new tag and all changes of the release.</li> </ol> <p>As an example see for e.g. the commit of <code>v0.1.1</code>, <code>c2582ed</code>.</p>"},{"location":"maintenance/#upload-to-pypi","title":"Upload to PyPI","text":"<p>There is an CI to publish new versions automatically. Therefore, a new release needs to be published. Please ensure that each release is based on a tag.</p>"},{"location":"maintenance/#build-and-upload-to-pypi-preferred","title":"Build and Upload to PyPI (preferred)","text":"<p>It is as simple as creating a new release from the new tag. The Github action will do the rest.</p>"},{"location":"maintenance/#build-and-upload-to-pypi-admin-only","title":"Build and Upload to PyPI (admin only)","text":"<p>For an introduction, please take a look at the PyPI manual.</p> <p>First ensure that all needed dependencies are installed <pre><code>python -m pip install --upgrade pip\npython -m pip install --upgrade build\npython -m pip install --upgrade twine\n</code></pre></p> <p>To create the build, please ensure first that the directory <code>dist</code> does not exist. Otherwise delete it, <pre><code>rm dist\n</code></pre> Then, execute <pre><code>python3 -m build\n</code></pre> which will create the directory <code>dist</code> including the source distributions: <pre><code>dist/\n\u251c\u2500\u2500 normi-0.*.*-py3-none-any.whl\n\u2514\u2500\u2500 normi-0.*.*.tar.gz\n</code></pre> To upload the new files, run <pre><code>python3 -m twine upload dist/*\n</code></pre></p>"},{"location":"maintenance/#update-on-conda-forge","title":"Update on Conda-Forge","text":"<p>Once a new version is published on PyPI, the conda-forge bot will automatically create a pull request on normi-feedstock.</p>"},{"location":"reference/","title":"normi","text":"<p>Normalized mutual information</p>"},{"location":"reference/#normi.NormalizedMI","title":"<code>NormalizedMI(*, n_dims=1, normalize_method='geometric', invariant_measure='volume', k=5, n_jobs=-1, verbose=True)</code>","text":"<p>               Bases: <code>BaseEstimator</code></p> <p>Class for estimating the normalized mutual information.</p> <p>Parameters:</p> <ul> <li> <code>n_dims</code>               (<code>int or list of ints</code>, default:                   <code>1</code> )           \u2013            <p>Dimensionality of input vectors.</p> </li> <li> <code>normalize_method</code>               (<code>str</code>, default:                   <code>'geometric'</code> )           \u2013            <p>Determines the normalization factor for the mutual information: - <code>'joint'</code> is the joint entropy - <code>'max'</code> is the maximum of the individual entropies - <code>'arithmetic'</code> is the mean of the individual entropies - <code>'geometric'</code> is the square root of the product of the individual   entropies - <code>'min'</code> is the minimum of the individual entropies</p> </li> <li> <code>invariant_measure</code>               (<code>str</code>, default:                   <code>'volume'</code> )           \u2013            <ul> <li><code>'radius'</code> normalizing by mean k-nn radius</li> <li><code>'volume'</code> normalizing by mean k-nn volume</li> <li><code>'kraskov'</code> no normalization</li> </ul> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of nearest neighbors to use in \\(k\\)-nn estimator.</p> </li> <li> <code>n_jobs</code>               (<code>Int</code>, default:                   <code>-1</code> )           \u2013            <p>Number of jobs to use, <code>-1</code> uses as many as cores are available.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Setting verbose mode.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>mi_</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>The pairwise mutual information matrix of the data.</p> </li> <li> <code>nmi_</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>The normalized pairwise mutual information matrix of the data.</p> </li> <li> <code>hxy_</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>The pairwise joint entropy matrix of the data.</p> </li> <li> <code>hx_</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>The pairwise entropy matrix of the data.</p> </li> <li> <code>hy_</code>               (<code>ndarray of shape (n_features, n_features)</code>)           \u2013            <p>The pairwise entropy matrix of the data.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from normi import NormalizedMI\n&gt;&gt;&gt; x = np.linspace(0, np.pi, 1000)\n&gt;&gt;&gt; data = np.array([np.cos(x), np.cos(x + np.pi / 6)]).T\n&gt;&gt;&gt; nmi = NormalizedMI()\n&gt;&gt;&gt; nmi.fit(data)\nNormalizedMI()\n&gt;&gt;&gt; nmi.nmi_\narray([[1.        , 0.79868365],\n       [0.79868365, 1.        ]])\n</code></pre> <p>Initialize NormalizedMI class.</p> Source code in <code>src/normi/_estimators.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    *,\n    n_dims: Union[ArrayLikePositiveInt, PositiveInt] = 1,\n    normalize_method: NormString = 'geometric',\n    invariant_measure: InvMeasureString = 'volume',\n    k: PositiveInt = 5,\n    n_jobs: Int = -1,\n    verbose: bool = True,\n):\n    \"\"\"Initialize NormalizedMI class.\"\"\"\n    self.n_dims: Union[ArrayLikePositiveInt, PositiveInt] = n_dims\n    self.normalize_method: NormString = normalize_method\n    self.invariant_measure: InvMeasureString = invariant_measure\n    self.k: PositiveInt = k\n    self.verbose: bool = verbose\n    self.n_jobs: Int = n_jobs\n</code></pre>"},{"location":"reference/#normi.NormalizedMI.fit","title":"<code>fit(X, y=None)</code>","text":"<p>Compute the normalized mutual information matrix.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features x n_dims)</code>)           \u2013            <p>Training data.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>self</code> (              <code>object</code> )          \u2013            <p>Fitted estimator.</p> </li> </ul> Source code in <code>src/normi/_estimators.py</code> <pre><code>@beartype\ndef fit(\n    self,\n    X: FloatMax2DArray,\n    y: Optional[ArrayLikeFloat] = None,\n):\n    \"\"\"Compute the normalized mutual information matrix.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features x n_dims)\n        Training data.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    self : object\n        Fitted estimator.\n\n    \"\"\"\n    self._reset()\n    _check_X(X=X, n_dims=self.n_dims)\n\n    # define number of features and samples\n    n_samples: int\n    n_cols: int\n    n_samples, n_cols = X.shape\n    self._n_samples: int = n_samples\n    if isinstance(self.n_dims, int):\n        self._n_features: int = n_cols // self.n_dims\n    else:\n        self._n_features: int = len(self.n_dims)\n\n    # scale input\n    X = StandardScaler().fit_transform(X)\n    if isinstance(self.n_dims, int):\n        X = np.split(X, self._n_features, axis=1)\n    else:\n        X = np.split(X, np.cumsum(self.n_dims), axis=1)[:-1]\n\n    self.mi_: FloatMatrix\n    self.hxy_: FloatMatrix\n    self.hx_: FloatMatrix\n    self.hy_: FloatMatrix\n\n    self.mi_, self.hxy_, self.hx_, self.hy_ = self._kraskov_estimator(X)\n\n    self.nmi_: NormalizedMatrix = self.nmi(\n        normalize_method=self.normalize_method,\n    )\n\n    return self\n</code></pre>"},{"location":"reference/#normi.NormalizedMI.fit_transform","title":"<code>fit_transform(X, y=None)</code>","text":"<p>Compute the normalized mutual information matrix and return it.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features x n_dims)</code>)           \u2013            <p>Training data.</p> </li> <li> <code>y</code>               (<code>Ignored</code>, default:                   <code>None</code> )           \u2013            <p>Not used, present for scikit API consistency by convention.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NMI</code> (              <code>ndarray of shape (n_features, n_features)</code> )          \u2013            <p>Pairwise normalized mutual information matrix.</p> </li> </ul> Source code in <code>src/normi/_estimators.py</code> <pre><code>@beartype\ndef fit_transform(\n    self,\n    X: FloatMax2DArray,\n    y: Optional[ArrayLikeFloat] = None,\n) -&gt; NormalizedMatrix:\n    \"\"\"Compute the normalized mutual information matrix and return it.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features x n_dims)\n        Training data.\n    y : Ignored\n        Not used, present for scikit API consistency by convention.\n\n    Returns\n    -------\n    NMI : ndarray of shape (n_features, n_features)\n        Pairwise normalized mutual information matrix.\n\n    \"\"\"\n    self.fit(X)\n    return self.nmi_\n</code></pre>"},{"location":"reference/#normi.NormalizedMI.transform","title":"<code>transform(X)</code>","text":"<p>Compute the correlation/nmi distance matrix and returns it.</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>ndarray of shape (n_samples, n_features) or str if low_memory=True</code>)           \u2013            <p>Training data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Similarity</code> (              <code>ndarray of shape (n_features, n_features)</code> )          \u2013            <p>Similarity matrix.</p> </li> </ul> Source code in <code>src/normi/_estimators.py</code> <pre><code>@beartype\ndef transform(\n    self,\n    X: Union[FloatMax2DArray, str],\n) -&gt; PositiveMatrix:\n    \"\"\"Compute the correlation/nmi distance matrix and returns it.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_samples, n_features) or str if low_memory=True\n        Training data.\n\n    Returns\n    -------\n    Similarity : ndarray of shape (n_features, n_features)\n        Similarity matrix.\n\n    \"\"\"\n    return self.fit_transform(X)\n</code></pre>"},{"location":"reference/#normi.NormalizedMI.nmi","title":"<code>nmi(normalize_method=None)</code>","text":"<p>Return the normalized mutual information matrix.</p> <p>Parameters:</p> <ul> <li> <code>normalize_method</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>If <code>None</code> use class definition. Determines the normalization factor for the mutual information: - <code>'joint'</code> is the joint entropy - <code>'max'</code> is the maximum of the individual entropies - <code>'arithmetic'</code> is the mean of the individual entropies - <code>'geometric'</code> is the square root of the product of the individual   entropies - <code>'min'</code> is the minimum of the individual entropies</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>nmi_</code> (              <code>ndarray of shape (n_features, n_features)</code> )          \u2013            <p>The normalized pairwise mutual information matrix of the data.</p> </li> </ul> Source code in <code>src/normi/_estimators.py</code> <pre><code>@beartype\ndef nmi(\n    self,\n    normalize_method: Optional[NormString] = None,\n) -&gt; NormalizedMatrix:\n    \"\"\"Return the normalized mutual information matrix.\n\n    Parameters\n    ----------\n    normalize_method : str, default=None\n        If `None` use class definition.\n        Determines the normalization factor for the mutual information:\n        - `'joint'` is the joint entropy\n        - `'max'` is the maximum of the individual entropies\n        - `'arithmetic'` is the mean of the individual entropies\n        - `'geometric'` is the square root of the product of the individual\n          entropies\n        - `'min'` is the minimum of the individual entropies\n\n    Returns\n    -------\n    nmi_ : ndarray of shape (n_features, n_features)\n        The normalized pairwise mutual information matrix of the data.\n\n    \"\"\"\n    check_is_fitted(self, attributes=['mi_', 'hxy_', 'hx_', 'hy_'])\n\n    if normalize_method is None:\n        normalize_method = self.normalize_method\n\n    nmi_: np.ndarray\n    if normalize_method == 'joint':\n        nmi_ = self.mi_ / self.hxy_\n    else:\n        func: Callable = {\n            'geometric': lambda arr: np.sqrt(np.prod(arr, axis=0)),\n            'arithmetic': lambda arr: np.mean(arr, axis=0),\n            'min': lambda arr: np.min(arr, axis=0),\n            'max': lambda arr: np.max(arr, axis=0),\n        }[normalize_method]\n        nmi_ = self.mi_ / func([self.hx_, self.hy_])\n\n    # ensure strict normalization within [0, 1]\n    return np.clip(nmi_, a_min=0, a_max=1)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>normi</li> <li>cli</li> </ul>"},{"location":"reference/cli/","title":"normi","text":"<p>Estimating NMI matrix of coordinates.</p> <p>Usage:</p> <pre><code>normi [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -i, --input PATH                Path to input file. Needs to be of shape\n                                  (n_samples, n_features). All command lines\n                                  need to start with \"#\". By default\n                                  np.float16 is used for the datatype.\n                                  [required]\n  -o, --output PATH               Path to output basename. Will be a matrix of\n                                  shape (n_features, n_features).  [required]\n  --norm [min|max|joint|arithmetic|geometric]\n                                  Normalization method of the mutual\n                                  information.  [default: geometric]\n  --inv-measure [volume|volume_stable|radius|kraskov]\n                                  Invariant measure to rescale the entropies.\n                                  [default: volume]\n  --n-dims INTEGER RANGE          Dimension of each feature. Assumes the first\n                                  nth colums belong to the first feature.\n                                  [default: 1; x&gt;=1]\n  --precision [half|single|double]\n                                  Precision used for calculation. Lower\n                                  precision reduces memory impact but may lead\n                                  to overflow errors.  [default: single]\n  -v, --verbose                   Activate verbose mode.\n  --help                          Show this message and exit.\n</code></pre>"}]}